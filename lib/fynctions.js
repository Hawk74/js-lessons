/*
# js-lessons

Рекурсия и стек
Вернёмся к функциям и изучим их более подробно.

Наша первая тема будет рекурсия.

Если вы не новичок в программировании, то, возможно, уже знакомы с рекурсией и можете пропустить эту главу.

Рекурсия – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных,
но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи. Или,
как мы скоро увидим, для работы с определёнными структурами данных.

В процессе выполнения задачи в теле функции могут быть вызваны другие функции для выполнения подзадач. Частный случай подвызова – когда функция вызывает сама себя. Это как раз и называется рекурсией.

Два способа мышления
В качестве первого примера напишем функцию pow(x, n), которая возводит x в натуральную степень n. Иначе говоря, умножает x на само себя n раз.

 */

function pow(x, n) {
    let result = 1;
    for (let i = 0; i < n; i++) {
        result *= x;
    }
    return result;
}

console.log(pow(2, 3));

function powRecursive(x, n) {
    if (n === 1) {
        return x;
    } else {
        return x * powRecursive(x, n - 1);
    }
}

function powBugRecursive(x, n) {

    if (n === 1) {

        return x;

    } else {

        return x * powBugRecursive(x, n--);

    }

}


// console.log((powBugRecursive = (x, n) =>  n === 1 ? x : x * powBugRecursive(x, n--))(2, 3));
/*

 Обратите внимание, что рекурсивный вариант отличается принципиально.

 Когда функция pow(x, n) вызывается, исполнение делится на две ветви:

                if n==1  = x
             /
 pow(x, n) =                                               if n==1  = x
             \                                          /
               else = x * pow(x, n - 1) --- pow(x, n) =
                                                        \  else = x * pow(x, n - 1)


    Если n == 1, тогда всё просто. Эта ветвь называется базой рекурсии, потому что сразу же приводит
    к очевидному результату: pow(x, 1) равно x.
    Мы можем представить pow(x, n) в виде: x * pow(x, n - 1).
    Что в математике записывается как: xn = x * xn-1.
    Эта ветвь – шаг рекурсии: мы сводим задачу к более простому действию (умножение на x) и более простой аналогичной задаче
    (pow с меньшим n). Последующие шаги упрощают задачу всё больше и больше, пока n не достигает 1.

    Говорят, что функция pow рекурсивно вызывает саму себя до n == 1.


 */


/*
        ------------    рекурсивный вызов до n==1
        | pow(x,n) |----------------
        ------------               |
             |                     |
            /\                     |
   --да--n === 1--нет-- x * pow(x, n -1)
   |        \/
   |
   x

    Например, рекурсивный вариант вычисления pow(2, 4) состоит из шагов:

    pow(2, 4) = 2 * pow(2, 3)
    pow(2, 3) = 2 * pow(2, 2)
    pow(2, 2) = 2 * pow(2, 1)
    pow(2, 1) = 2


 */


/*
    Рекурсивное решение обычно короче
    Рекурсивное решение задачи обычно короче, чем итеративное.

    Используя условный оператор ? вместо if, мы можем переписать pow(x, n), делая код функции более лаконичным, но всё ещё легко читаемым:

    function pow(x, n) {
      return (n == 1) ? x : (x * pow(x, n - 1));
    }
 */

/*
    Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии. В нашем случае она будет равна ровно n.

    Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов,
    некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей.
    Существуют автоматические оптимизации, помогающие избежать переполнения стека вызовов («оптимизация хвостовой рекурсии»),
    но они ещё не поддерживаются везде и работают только для простых случаев.

    Это ограничивает применение рекурсии, но она всё равно широко распространена: для решения большого числа задач рекурсивный
    способ решения даёт более простой код, который легче поддерживать.

 */